package cs3500.set.controller;import java.io.IOException;import java.util.Scanner;import cs3500.set.model.hw02.Coord;import cs3500.set.model.hw02.SetGameModel;import cs3500.set.view.SetGameView;/** * Controller for the SetGameModel that will take in a model and a view as parameters, read what the * model says to do, and pass it so the view can render the correct board. */public class SetGameControllerImpl implements SetGameController {  private final SetGameModel model;  private final SetGameView view;  private final Readable readable;  /**   * Constructor for the controller. It takes in a SetGameModel (in this case we only have a   * SetThreeGameModel), and SetGameView (SetGameTextView), and a Readable.   *   * @param model    represents the rules for the game. We have the SetThreeGameModel.   * @param view     represents the view for the model we will be giving the user.   *                 We have a text view called SetGameTextView for now.   * @param readable represents the object that will take in the input.   * @throws IllegalArgumentException when any of the given objects are null.   */  public SetGameControllerImpl(SetGameModel model, SetGameView view, Readable readable)          throws IllegalArgumentException {    if (model == null || view == null || readable == null) {      throw new IllegalArgumentException("Parameters cannot be null");    }    this.model = model;    this.view = view;    this.readable = readable;  }  /**   * Plays the game by asking for a series of integers for rows and values that gets parsed into   * the game to render the board, and calculate valid sets.   *   * @throws IllegalStateException when the   */  @Override  public void playGame() throws IllegalStateException {    boolean quit = false;    boolean gameOver = false;    boolean gameStarted = false;    Scanner scanner = new Scanner(readable);    // Starts the game if it has not been quit or if the game is not over.    while (!quit && !gameOver) {      if (!gameStarted) {        message("Enter row and column values here, or type 'q' to quit");        try {          int rowInt;          int colInt;          String rowValue = scanner.next();          if (rowValue.equalsIgnoreCase("q")) {            startQuitMessage();            return;          }          // Gets the row height for the board.          try {            rowInt = Integer.parseInt(rowValue);          } catch (NumberFormatException e) {            message("Enter value again");            continue;          }          String colValue = scanner.next();          if (colValue.equalsIgnoreCase("q")) {            startQuitMessage();            return;          }          // Gets the column width for the board.          try {            colInt = Integer.parseInt(colValue);          } catch (NumberFormatException e) {            message("Enter value again");            continue;          }          // Checks to make sure that the given row width and col height are accepted by the model.          try {            model.startGameWithDeck(model.getCompleteDeck(), rowInt, colInt);            gameStarted = true;          } catch (IllegalArgumentException e) {            try {              view.renderMessage("Invalid height/width. Try again." + System.lineSeparator());              continue;            } catch (IOException ioe) {              throw new IllegalStateException("There was an error reading the input and output");            }          }        } catch (IllegalStateException | IllegalArgumentException e) {          throw new IllegalStateException();        }      }      // Tries to render the grid and the score, but throws IOException if it fails      try {        view.renderGrid();        view.renderMessage(System.lineSeparator()                + "Score: " + model.getScore()                + System.lineSeparator());        view.renderMessage("Enter 3 row and column values here, or type 'q' to quit"                + System.lineSeparator());      } catch (IOException e) {        throw new IllegalStateException("Failed to render opening message");      }      // Parses the row and column coordinate values using a helper.      int row1Int = parseInt(scanner, true);      if (row1Int == -1) {        return;      }      int col1Int = parseInt(scanner, false);      if (col1Int == -1) {        return;      }      int row2Int = parseInt(scanner, true);      if (row2Int == -1) {        return;      }      int col2Int = parseInt(scanner, false);      if (col2Int == -1) {        return;      }      int row3Int = parseInt(scanner, true);      if (row3Int == -1) {        return;      }      int col3Int = parseInt(scanner, false);      if (col3Int == -1) {        return;      }      // creates 3 coords and passes them into the model.      Coord coord1 = new Coord(row1Int, col1Int);      Coord coord2 = new Coord(row2Int, col2Int);      Coord coord3 = new Coord(row3Int, col3Int);      try {        model.claimSet(coord1, coord2, coord3);        message("Score Increased");      } catch (IllegalArgumentException e) {        message("Invalid claim. Try again.");      } catch (IllegalStateException e2) {        message("Invalid state");      }      if (model.isGameOver()) {        gameOver = true;        farewellMessage();      }    }  }  /**   * parses the given input by the given scanner. If the value is a 'q' or a 'Q', then it returns   * -1, for any other non integer, it tells the user to try again. If the user passes in an   * integer it will return that int.   *   * @param scanner given scanner to read the input.   * @return an int that represents a Coord value.   */  private int parseInt(Scanner scanner, boolean isRow) {    int upperBound;    if (isRow) {      upperBound = model.getHeight();    } else {      upperBound = model.getWidth();    }    boolean validCoordValue = false;    int coordValue = 0;    while (!validCoordValue) {      String value;      if (scanner.hasNext()) {        value = scanner.next();      } else {        throw new IllegalStateException("Scanner does not have next");      }      try {        if (value.equalsIgnoreCase("Q")) {          quitMessage();          return -1;        }        coordValue = Integer.parseInt(value);        if (coordValue <= upperBound && coordValue >= 1) {          coordValue -= 1;          validCoordValue = true;        } else {          message("Enter a valid coordinate" + System.lineSeparator());        }      } catch (NumberFormatException n) {        message("Enter a number instead of a letter");      }    }    return coordValue;  }  /**   * Renders any given message in the View class.   *   * @param msg represents a string you want to tell the user.   * @throws IllegalStateException when it catches an IOException.   */  private void message(String msg) throws IllegalStateException {    try {      view.renderMessage(msg + System.lineSeparator());    } catch (IOException e) {      throw new IllegalStateException("Failed to render message");    }  }  /**   * Renders the farewell message at the end of the game.   *   * @throws IllegalStateException when it catches an IOException.   */  private void farewellMessage() throws IllegalStateException {    try {      view.renderMessage("Game over!" + System.lineSeparator() + "Score: " + model.getScore());    } catch (IOException e) {      throw new IllegalStateException("Failed to render farewell message");    }  }  /**   * Renders the quit message when the user attempts to quit before they start the game. This is   * separate because this method does not read the model, as that would throw an   * IllegalStateException   *   * @throws IllegalStateException when it catches an IOException.   */  private void startQuitMessage() throws IllegalStateException {    try {      view.renderMessage("Game quit!" + System.lineSeparator() + "Score: 0");    } catch (IOException e) {      throw new IllegalStateException("Failed to render pre-game quit message");    }  }  /**   * Renders the quit message when the user attempts to quit after the game has started. This reads   * the model to get the current score.   *   * @throws IllegalStateException when it catches an IOException.   */  private void quitMessage() throws IllegalStateException {    try {      view.renderMessage("Game quit!" + System.lineSeparator() + "State of game when quit:"              + System.lineSeparator());      view.renderGrid();      view.renderMessage(System.lineSeparator() + "Score: " + model.getScore());    } catch (IOException e) {      throw new IllegalStateException("Failed to render quit message");    }  }}