package cs3500.set.model.hw03;import java.util.ArrayList;import java.util.Collections;import java.util.List;import cs3500.set.model.hw02.Card;import cs3500.set.model.hw02.Coord;import cs3500.set.model.hw02.Count;import cs3500.set.model.hw02.Filling;import cs3500.set.model.hw02.SetGameModel;import cs3500.set.model.hw02.Shape;/** * Abstract class for SetGameModels that takes out common methods to reduce repeated code. */public abstract class AbstractSetGameModel implements SetGameModel<Card> {  protected Card[][] cardGrid;  protected List<Card> deck;  protected List<Coord> coordsToClaims;  protected int height;  protected int width;  protected int score;  public boolean gameStarted;  protected boolean gameOver;  /**   * Constructor for the AbstractSetGameModel that initializes the cardGrid, the score, and the sets   * gameStarted and gameOver to false.   */  public AbstractSetGameModel() {    this.cardGrid = new Card[height][width];    this.deck = new ArrayList<>();    this.coordsToClaims = new ArrayList<>();    this.score = 0;    this.gameStarted = false;    this.gameOver = false;  }  /**   * Adds cards to the list of cards to claim.   *   * @param coord the card to be added to the list of cards to claim   */  public void addToClaimsList(Coord coord) {    if (!coordsToClaims.contains(coord)) {      coordsToClaims.add(coord);    }  }  /**   * Determines if there are enough cards to claim.   *   * @return true if there are 3 cards to claim, false otherwise   */  public boolean enoughCardsToClaim() {    return coordsToClaims.size() == 3;  }  /**   * Removes all cards from the cards to claim list.   */  public void removeCardsToClaim() {    if (enoughCardsToClaim()) {      coordsToClaims.clear();    }  }  public Coord getCoord(int index, List<Coord> deck) {    return deck.get(index);  }  public List<Coord> getClaimsList() {    return coordsToClaims;  }  /**   * If the cards at the specified coordinates form a valid set, claim it,   * and replace those cards with new cards from the deck, if possible.   *   * @param coord1 the coordinates of the first card   * @param coord2 the coordinates of the second card   * @param coord3 the coordinates of the third card   * @throws IllegalArgumentException if any of the coordinates are invalid for the particular   *                                  implementation of Set OR the cards at   *                                  those coordinates do not form a set   * @throws IllegalStateException    if the game has not started or the game has already ended   */  public void abstractClaimSet(Coord coord1, Coord coord2, Coord coord3)          throws IllegalArgumentException,          IllegalStateException {    if (!this.gameStarted || this.gameOver) {      throw new IllegalStateException("Game state is not valid to claim a set");    } else if (coord1 == null || coord2 == null || coord3 == null            || this.isInvalidCoords(coord1, coord2, coord3)            || !isValidSet(coord1, coord2, coord3)) {      throw new IllegalArgumentException("These coords do not form a set");    } else if (coord1.equals(coord2) || coord2.equals(coord3) || coord3.equals(coord1)) {      throw new IllegalArgumentException("The coords must be different");    } else if (isValidSet(coord1, coord2, coord3)) {      score += 1;      if (this.deck.size() >= 3) {        cardGrid[coord1.row][coord1.col] = this.deck.get(0);        this.deck.remove(0);        cardGrid[coord2.row][coord2.col] = this.deck.get(0);        this.deck.remove(0);        cardGrid[coord3.row][coord3.col] = this.deck.get(0);        this.deck.remove(0);      } else {        cardGrid[coord1.row][coord1.col] = null;        cardGrid[coord2.row][coord2.col] = null;        cardGrid[coord3.row][coord3.col] = null;        this.gameOver = true;      }    }  }  /**   * Begins the game using the cards given by the deck creates a grid specified   * by the height and width parameters.   * Specifically, the model deals the cards onto the board from left to right and top to bottom,   * filling the grid.   *   * @param deck   the list of cards in the order they will be played   * @param height the height of the board for this game   * @param width  the width of the board for this game   * @throws IllegalArgumentException if the deck does not have enough cards to deal 9 cards to the   *                                  grid,   *                                  OR the deck is null,   *                                  OR the width/height are not 3   */  public void abstractStartGameWithDeck(List<Card> deck, int height, int width) throws          IllegalArgumentException, IllegalStateException {    this.height = height;    this.width = width;    this.deck = deck;    this.score = 0;    this.gameStarted = true;    this.cardGrid = new Card[height][width];    this.gameOver = false;    for (int i = 0; i < height; i++) {      for (int j = 0; j < width; j++) {        cardGrid[i][j] = deck.get(0);        deck.remove(0);      }    }  }  /**   * Helper method that returns true if the coords are out of bounds.   * i.e. a coordinate is greater than 2 or is a negative integer.   *   * @param coord1 the coordinates of the first card   * @param coord2 the coordinates of the second card   * @param coord3 the coordinates of the third card   * @return a boolean representing if any of the coordinates provided are out of bounds   */  public boolean isInvalidCoords(Coord coord1, Coord coord2, Coord coord3) {    return coord1.row < 0 || coord1.row > this.height || coord1.col < 0            || coord1.col > this.width            || coord2.row < 0 || coord2.row > this.height || coord2.col < 0            || coord2.col > this.width            || coord3.row < 0 || coord3.row > this.height || coord3.col < 0            || coord3.col > this.width;  }  /**   * Returns true if and only if there are any sets in the currently dealt board.   *   * @return if there are any sets available   * @throws IllegalStateException if the game has not yet started   */  public boolean anySetsPresent() throws IllegalStateException {    if (!this.gameStarted) {      throw new IllegalStateException("Game state isn't valid to call this method");    }    List<Coord> coordList = new ArrayList<>();    for (int i = 0; i < this.getHeight(); i++) {      for (int j = 0; j < this.getWidth(); j++) {        Coord coord = new Coord(i, j);        coordList.add(coord);      }    }    for (int i = 0; i < coordList.size() - 2; i++) {      for (int j = i + 1; j < coordList.size() - 1; j++) {        for (int k = j + 1; k < coordList.size(); k++) {          if (isValidSet(coordList.get(i), coordList.get(j), coordList.get(k))) {            return true;          }        }      }    }    return false;  }  /**   * Returns true if cards at the specified coordinates form a valid set.   *   * @param coord1 the coordinates of the first card   * @param coord2 the coordinates of the second card   * @param coord3 the coordinates of the third card   * @return whether the cards form a valid set   * @throws IllegalArgumentException if any of the coordinates are invalid for the given   *                                  implementation of Set   * @throws IllegalStateException    if the game has not yet started or if the game is over   */  public boolean isValidSet(Coord coord1, Coord coord2, Coord coord3)          throws IllegalArgumentException, IllegalStateException {    if (!this.gameStarted || this.gameOver) {      throw new IllegalStateException("Game state is not valid to check a set");    } else if (coord1 == null || coord2 == null || coord3 == null            || this.isInvalidCoords(coord1, coord2, coord3)) {      throw new IllegalArgumentException("These coords do not form a valid set");    }    Card card1 = getCardAtCoord(coord1);    Card card2 = getCardAtCoord(coord2);    Card card3 = getCardAtCoord(coord3);    if (!(card1.getCount() == card2.getCount() && card2.getCount() == card3.getCount()            || card1.getCount() != card2.getCount() && card2.getCount() != card3.getCount()            && card1.getCount() != card3.getCount())) {      return false;    } else if (!(card1.getFilling() == card2.getFilling() && card2.getFilling()            == card3.getFilling()            || card1.getFilling() != card2.getFilling() && card2.getFilling() != card3.getFilling()            && card1.getFilling() != card3.getFilling())) {      return false;    } else {      return card1.getShape() == card2.getShape() && card2.getShape() == card3.getShape()              || card1.getShape() != card2.getShape() && card2.getShape() != card3.getShape()              && card1.getShape() != card3.getShape();    }  }  /**   * Returns the card at the given row and column.   *   * @param row the row of the desired card   * @param col the column of the desired card   * @return the card with the given row and column   * @throws IllegalArgumentException when the row or column is lower than 0 or higher than 2   * @throws IllegalStateException    when the method is called before the game started or when the   *                                  game has ended   */  @Override  public Card getCardAtCoord(int row, int col) {    if (row < 0 || row > this.getHeight() || col < 0 || col > this.getWidth()) {      throw new IllegalArgumentException("Invalid coordinates");    } else if (!this.gameStarted || this.gameOver) {      throw new IllegalStateException("Game state is not valid to get a card");    }    return cardGrid[row][col];  }  /**   * Returns the card at the given coord.   *   * @param coord the coordinates of the desired card   * @return the card at the given coord   * @throws IllegalArgumentException when the row or column is lower than 0 or higher than 2   * @throws IllegalStateException    when the method is called before the game started or when the   *                                  game has ended   */  @Override  public Card getCardAtCoord(Coord coord) {    if (coord.row < 0 || coord.row > this.getHeight() || coord.col < 0            || coord.col > this.getWidth() || coord == null) {      throw new IllegalArgumentException("Invalid coordinates");    } else if (!this.gameStarted || this.isGameOver()) {      throw new IllegalStateException("Game state is not valid to get coordinates");    }    return cardGrid[coord.row][coord.col];  }  /**   * Return the width of the grid for this game of Set.   *   * @return the width of the grid   * @throws IllegalStateException if the game has not yet started or if the game is over   */  public int getWidth() throws IllegalStateException {    if (!this.gameStarted || this.gameOver) {      throw new IllegalStateException("Game state isn't valid to call this method");    }    return width;  }  /**   * Return the height of the grid for this game of Set.   *   * @return the height of the grid   * @throws IllegalStateException if the game has not yet started of if the game is over   */  public int getHeight() throws IllegalStateException {    if (!this.gameStarted || this.gameOver) {      throw new IllegalStateException("Game state isn't valid to call this method");    }    return height;  }  /**   * Returns how many sets the player has collected so far.   *   * @return the player's current score   * @throws IllegalStateException if the game has not yet started   */  public int getScore() throws IllegalStateException {    if (!this.gameStarted) {      throw new IllegalStateException("Game hasn't started yet");    }    return this.score;  }  /**   * Craft and return a new complete deck for the implemented game.   * This deck must contain every possible card possible in the implemented game   * exactly once.   * There is no required/sorted order for the cards in this deck.   *   * @return the complete deck of cards   */  @Override  public List<Card> getCompleteDeck() {    ArrayList<Card> completeDeck = new ArrayList<>();    for (Count c : Count.values()) {      for (Filling f : Filling.values()) {        for (Shape s : Shape.values()) {          completeDeck.add(new Card(c, f, s));        }      }    }    Collections.shuffle(completeDeck);    return completeDeck;  }  /**   * Return true when the game is over. That happens when:   * 1. there no sets on the current board OR   * 2. there are not enough cards remaining in the deck to deal after claiming a set   *   * @return whether the game is over   */  @Override  public boolean isGameOver() {    return this.gameOver;  }}